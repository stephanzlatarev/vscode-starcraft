<!DOCTYPE html>
<html>

<style>
html, body {
  margin: 0px;
  padding: 0px;
  overflow: hidden;
}
#mouse {
  position: absolute;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: transparent;
}
.building {
  clip-path: inset(0 0 0 0 round 10%);
}
.unit {
  clip-path: inset(0 0 0 0 round 50%);
}
.select {
  fill: orange;
  stroke: orange;
  stroke-width: 0.2;
}
.wip {
  filter: grayscale(40%);
  opacity: 0.7;
}
.cloak {
  opacity: 0.5;
}
</style>

<body>
<svg id="map" width="100" height="100" viewBox="0 0 0 0" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
  <rect x="-1000" y="-1000" width="2000" height="2000" fill="black" />
  <g id="grid" style="stroke: none"></g>
  <g id="zonelines" style="stroke: darkgoldenrod; stroke-width: 0.4; fill: none;"></g>
  <g id="zonetexts" style="fill: darkgoldenrod; font-size: 8"></g>
  <g id="units"></g>
  <g id="focus" style="stroke: gold; stroke-width: 0.4; fill: none"></g>
</svg>
<div id="mouse" />
</body>

<script>
const ZOOM_ICONS_THRESHOLD = 100;
const OWNER_COLOR = ["white", "blue", "red"];
const ZONE_COLS = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"];

const map = document.getElementById("map");
const layerFocus = document.getElementById("focus");
const layerGrid = document.getElementById("grid");
const layerUnits = document.getElementById("units");
const layerMouse = document.getElementById("mouse");
const vscode = acquireVsCodeApi();

let viewbox = { left: 0, top: 0, width: 0, height: 0 };
let mapbox;
let camera = null;
let iconspath = null;
let grid = null;
let lastKeyCode = null;
let lastKeyDown = false;
let lastKeyHold = false;
let selection = null;

function setIconsPath(path) {
  iconspath = path;
}

function resetCamera() {
  viewbox = { left: 0, top: 0, width: 0, height: 0 };
  grid = null;
  selection = null;

  map.setAttribute("viewBox", "0 0 0 0");
  layerFocus.replaceChildren();
  layerGrid.replaceChildren();
  layerUnits.replaceChildren();
}

function setViewBox(box) {
  if ((box === viewbox) || ((box.left === viewbox.left) && (box.top === viewbox.top) && (box.width === viewbox.width) && (box.height === viewbox.height))) {
    // Viewbox doesn't change
  } else if ((box.x >= 0) && (box.y >= 0)) {
    const width = window.innerWidth * box.span / 1000;
    const height = width * window.innerHeight / window.innerWidth;

    viewbox = {
      left: box.x - width / 2,
      top: box.y - height / 2,
      width: width,
      height: height,
    };

    camera = { ...box };
  } else {
    viewbox = { ...box };
    camera = null;
  }

  if (grid && mapbox) {
    const minx = Math.floor(Math.max(mapbox.minx, viewbox.left));
    const maxx = Math.ceil(Math.min(mapbox.maxx, viewbox.left + viewbox.width));
    const miny = Math.floor(Math.max(mapbox.miny, viewbox.top));
    const maxy = Math.ceil(Math.min(mapbox.maxy, viewbox.top + viewbox.height));
    const svg = [];

    for (let x = minx; x < maxx; x++) {
      for (let y = miny; y < maxy; y++) {
        const color = getCellColor(x, y);

        if (color) {
          svg.push(`<rect x="${x + 0.01}" y=${y + 0.01} width="${0.98}" height="${0.98}" fill="${color}" />`);
        }
      }
    }

    layerGrid.innerHTML = svg.join("");
  }

  if (
    mapbox &&
    (viewbox.left === mapbox.minx) && (viewbox.top === mapbox.miny) &&
    (viewbox.left + viewbox.width === mapbox.maxx) && (viewbox.top + viewbox.height === mapbox.maxy)
  ) {
    const lines = [];
    const texts = [];
    const stepx = viewbox.width / 10;
    const maxx = viewbox.left + viewbox.width;
    const stepy = viewbox.height / 10;
    const maxy = viewbox.top + viewbox.height;

    for (let x = viewbox.left, i = 0; x < maxx; x += stepx, i++) {
      lines.push(`<line x1="${x + stepx}" y1="0" x2="${x + stepx}" y2="${maxy}" />`);
      texts.push(`<text x="${x + stepx * 0.5}" y="${viewbox.top + stepy * 0.5}">${ZONE_COLS[i]}</text>`);
    }
    for (let y = viewbox.top, i = 0; y < maxy; y += stepy, i++) {
      lines.push(`<line x1="0" y1="${y + stepy}" x2="${maxx}" y2="${y + stepy}" />`);
      texts.push(`<text x="${viewbox.left + stepx * 0.1}" y="${y + stepy * 0.8}">${i}</text>`);
    }

    document.getElementById("zonelines").innerHTML = lines.join("");
    document.getElementById("zonetexts").innerHTML = texts.join("");
  } else {
    document.getElementById("zonelines").innerHTML = "";
    document.getElementById("zonetexts").innerHTML = "";
  }

  map.setAttribute("viewBox", [viewbox.left, viewbox.top, viewbox.width, viewbox.height].join(" "));

  vscode.postMessage({ type: "viewbox", viewbox });
}

function setFocus(x, y, span) {
  layerFocus.innerHTML = `<rect x="${x - span / 2}" y=${y - span / 2} width="${span}" height="${span}" />`;
}

function setGrid(size, placement, pathing) {
  grid = { size, placement, pathing };

  setViewBox(viewbox);
}

function setUnits(units) {
  const svg = [];

  if (viewbox.width < ZOOM_ICONS_THRESHOLD) {
    for (const unit of units) {
      const color = OWNER_COLOR[unit.owner] || "white";

      if (unit.order) {
        const order = unit.order;
        const distance = Math.abs(unit.x - order.x) + Math.abs(unit.y - order.y);
        const opacity = Math.max(1 - distance / 50, 0.1);
        svg.push(`<line x1="${unit.x}" y1="${unit.y}" x2="${order.x}" y2="${order.y}" stroke="${color}" stroke-width="0.4" stroke-opacity="${opacity}" />`);
      }
    }
  }

  for (const unit of units) {
    const color = OWNER_COLOR[unit.owner] || "white";

    if (viewbox.width < ZOOM_ICONS_THRESHOLD) {
      if (unit.type) {
        let c = "building";
        let x, y, width, height;

        if (unit.type.kind === 2) {
          // Mineral field
          x = unit.x - 1;
          y = unit.y - 0.5;
          width = 2;
          height = 1;
        } else if (unit.type.kind === 3) {
          // Vespene geyser
          x = unit.x - 1.5;
          y = unit.y - 1.5;
          width = 3;
          height = 3;
        } else if ((unit.owner !== 1) && (unit.owner !== 2)) {
          // Obstacle
          x = unit.x - 0.5;
          y = unit.y - 0.5;
          width = 1;
          height = 1;
        } else if (unit.type.kind === 1) {
          // Player's building
          const size = Math.floor(unit.r + unit.r);
          const radius = size / 2;

          x = unit.x - radius;
          y = unit.y - radius;
          width = size;
          height = size;
        } else {
          // Player's unit
          c = "unit";
          x = unit.x - unit.r;
          y = unit.y - unit.r;
          width = unit.r + unit.r;
          height = unit.r + unit.r;
        }

        const wip = unit.wip ? "wip" : "";
        const cloak = unit.cloak ? "cloak" : "";
        const select = (unit.tag === selection) ? "select" : "";

        svg.push(`<rect class="${c} ${select} ${wip} ${cloak}" x="${x}" y="${y}" width="${width}" height="${height}" fill="${color}" />`);

        if (iconspath && unit.type.alias) {
          const href = iconspath + unit.type.alias + ".webp";
          const onerror = `onerror="this.style.display='none'"`;

          svg.push(`<image class="${c} ${wip} ${cloak}" x="${x}" y="${y}" width="${width * 0.95}" height="${height * 0.95}" href="${href}" ${onerror} />`);
        }

        if (iconspath && unit.product) {
          const href = iconspath + unit.product.type + ".webp";
          const onerror = `onerror="this.style.display='none'"`;

          svg.push(`<image x="${x + 0.2}" y="${y + 0.2}" width="1" height="1" href="${href}" ${onerror} />`);
          svg.push(`<rect x="${x + 0.2}" y="${y + 0.2}" width="1" height="${1 - unit.product.progress}" fill="#555555" opacity="0.8" />`);
        }
      } else {
        svg.push(`<circle cx="${unit.x}" cy="${unit.y}" r="${unit.r - 0.1}" stroke="${color}" stroke-width="0.2" fill="black" />`);
      }
    } else {
      if (unit.type && (unit.owner !== 1) && (unit.owner !== 2) && (unit.type.kind !== 2) && (unit.type.kind !== 3)) {
        // This is some kind of obstacle with unclear dimensions
        svg.push(`<circle cx="${unit.x}" cy="${unit.y}" r="0.5" stroke="none" fill="${color}" />`);
      } else {
        svg.push(`<circle cx="${unit.x}" cy="${unit.y}" r="${Math.max(unit.r, 1)}" stroke="none" fill="${color}" />`);
      }
    }
  }

  layerUnits.innerHTML = svg.join("");
}

function getCellColor(x, y) {
  if (!grid || (x < 0) || (x > grid.size.x) || (y < 0) || (y > grid.size.y)) return "black";

  const index = x + y * grid.size.x;
  const pos = 7 - index % 8;
  const mask = 1 << pos;
  const bit = Math.floor(index / 8);

  if (grid.placement[bit] & mask) {
    // Placement cell
    return "#CCCCCC";
  } else if (grid.pathing[bit] & mask) {
    // Pathing cell
    return "#AAAAAA";
  }
}

window.addEventListener("resize", function(event) {
  map.setAttribute("width", window.innerWidth);
  map.setAttribute("height", window.innerHeight);

  if (camera) setViewBox(camera);
}, true);

window.addEventListener("message", function({ data }) {
  switch (data.type) {
    case "focus": return setFocus(data.x, data.y, data.span);
    case "icons": return setIconsPath(data.path);
    case "grid": return setGrid(data.size, data.placement, data.pathing);
    case "mapbox": return mapbox = data.mapbox;
    case "reset": return resetCamera();
    case "select": return (selection = data.unit);
    case "units": return setUnits(data.units);
    case "viewbox": return setViewBox(data.viewbox);
  }
});

const IS_ARROW_KEY = { ArrowLeft: true, ArrowRight: true, ArrowUp: true, ArrowDown: true };
window.addEventListener("keydown", function(event) {
  const isHold = lastKeyDown && (event.code === lastKeyCode);
  if (event.code === "Space") {
    vscode.postMessage({ event: "pause" });
  } else if (camera && isHold && IS_ARROW_KEY[event.code]) {
    moveCamera(event.code, 1);
  }
  lastKeyCode = event.code;
  lastKeyDown = true;
  lastKeyHold = isHold;
});
window.addEventListener("keyup", function(event) {
  if (camera && lastKeyDown && !lastKeyHold && (event.code === lastKeyCode) && IS_ARROW_KEY[event.code]) {
    moveCamera(event.code, 12);
  }
  lastKeyCode = event.code;
  lastKeyDown = false;
  lastKeyHold = false;
});
function moveCamera(arrow, step) {
  let x = camera.x;
  let y = camera.y;

  if (arrow === "ArrowLeft") {
    x -= step;
  } else if (arrow === "ArrowUp") {
    y -= step;
  } else if (arrow === "ArrowRight") {
    x += step;
  } else if (arrow === "ArrowDown") {
    y += step;
  }

  vscode.postMessage({ event: "scroll", x, y });
}

window.addEventListener("wheel", function(event) {
  vscode.postMessage({
    event: "wheel",
    delta: event.deltaY,
    x: Math.round(viewbox.left + event.offsetX * viewbox.width / window.innerWidth),
    y: Math.round(viewbox.top + event.offsetY * viewbox.height / window.innerHeight),
  });
});

layerMouse.addEventListener("click", function(event) {
  vscode.postMessage({
    event: "click",
    x: Math.round(viewbox.left + event.offsetX * viewbox.width / window.innerWidth),
    y: Math.round(viewbox.top + event.offsetY * viewbox.height / window.innerHeight),
  });
});

map.setAttribute("width", window.innerWidth);
map.setAttribute("height", window.innerHeight);
</script>

</html>
